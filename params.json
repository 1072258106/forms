{
  "name": "Forms",
  "tagline": "A library to easily create forms written in Kotlin",
  "body": "# Form library\r\n\r\n*Work in progress...*\r\n\r\n## Goal\r\n\r\nThe purpose of this library is to *abstract* the concept of a form composed by fields of various types\r\n(checkboxes, text inputs, pickers etc.) and allow to easily describe their structure and relationships.\r\nThe goal is to be able to statically define a form in a single file that contains all the\r\ninformation needed to build and present it. For this reason the library provides both \"model\"\r\ncomponents and UI components (Android stuff).\r\n\r\nAnother feature is the possibility to define how the form should be \"serialized\" into a data structure\r\ncomposed by pair of key-values that could be easily converted into a JSON file or something equivalent.\r\n\r\nThe library is written using [Kotlin](kotlinlang.org) and its only dependency is RxJava.\r\n\r\n## Structure\r\n\r\nThe library is divided between three main logic modules:\r\n- Storage (Kotlin only)\r\n- Model (Kotlin only)\r\n- UI (Android dependencies)\r\n\r\nIn the future it will be dived in two separated modules allowing us to use the Model/Storage layer\r\nregardless of Android, maybe within the web world, thanks to Kotlin's ability to be compiled into\r\nJavaScript.\r\n\r\n\r\n\r\n### Storage\r\nThe Storage is the place where all the values, defaults or entered by the user, are stored. It is\r\nbasically a dictionary of keys (simple strings) and Entry with accessory methods used to manipulate it.\r\n\r\n```kotlin\r\n// The definition of the entries stored within the Storage\r\ndata class Entry(val value: FieldValue, val hidden: Boolean = false, val disabled: Boolean = false)\r\n\r\n```\r\nEvery entry contains information about its value, visibility and if it is enabled.\r\nPossible values are:\r\n- Text - a simple string\r\n- Bool - a simple boolean\r\n- DateValue - a simple date\r\n- Object - a generic object that should have a key and be describable (DescribableWithKey)\r\n- Missing - represents the absence of the value\r\n\r\n### Model\r\nThe Model is the key of the library in the sense that it allows you to define the form model that is\r\nits structure.\r\n\r\nA form could be structured into pages (PageModel), sections (SectionModel), and fields (FieldModel).\r\n\r\n\r\n\r\n\r\n### UI\r\n\r\n## Modules interaction\r\n\r\n## Add the UI\r\n\r\n### Setup\r\nIn order to use the form UI, add `FormRecyclerView` to your layout\r\n```\r\n<it.facile.form.ui.FormRecyclerView\r\n    android:layout_width=\"match_parent\"\r\n    android:layout_height=\"match_parent\">\r\n</it.facile.form.ui.FormRecyclerView>\r\n```\r\n`FormRecyclerView` is a simple `RecyclerView` with `LinearLayoutManager` as default layout manager and the\r\n`FormItemAnimator` as default item animator. (NB: to use a custom ItemAnimator make sure to extends\r\n`FormDefaultItemAnimator` to prevent problems with Input Text fields)\r\n\r\nNext you have should have your view (an `Activity`, a `Fragment` or whatever you want to contain the form)\r\nimplement `FormView` interface and implement its methods:\r\n\r\n```kotlin\r\n// Where your view receives the list of PageViewModel and initalizes the\r\n// components (recyclerview, adapters..) used to display them\r\nfun init(pageViewModels: List<PageViewModel>)\r\n// Where you should update a field with new informations\r\nfun updateField(path: FieldPath,\r\n                viewModel: FieldViewModel,\r\n                sectionViewModel: SectionViewModel)\r\n// With this method your should expose an Observable to that emits value entered by the user\r\nfun observeValueChanges(): Observable<FieldPathWithValue>\r\n```\r\n\r\nThe most important thing is `PageAdapter` used to display pages containing sections and fields using\r\na `Fragment` for every form page. It should be instantiated with the list of `PageViewModel`\r\navailable within `init()` method.\r\n\r\nLast but not least you have to instantiate a `FormPresenter` passing it the Model and to **remember to call**\r\n`onAttach()` and `onDetach()` methods typically within `onStop()` and `onStart()`.\r\n\r\n### Custom Fields layout\r\n\r\nIn order to use different layouts for fields you have to pass to `PagesAdapter` (or `SectionsAdapter` if you have\r\na single page) a `FieldsLayouts`. Using Kotlin's named parameters you will be able to provide a layout\r\nid only for the fields that you want to customize:\r\n```kotlin\r\nval fieldsLayouts = FieldsLayouts(\r\n            text = R.layout.custom_text_layout,\r\n            checkBox= R.layout.custom_checkbox_layout)\r\nval adapter = PagesAdapter(pageViewModels, fieldsLayouts, supportFragmentManager)\r\n```\r\nThe only rule to follow when implementing custom layouts is that they should include a predefined set\r\nof views with particular ids.\r\n\r\n##### Text Field\r\n- `textLabel`\r\n- `textView`\r\n- `textErrorText`\r\n- `textErrorImage`\r\n\r\n##### Input Text Field\r\nThe input type is a particular one, in the sense that if you use Android support `TextInputLayout` you have to\r\nspecify only its id (the view has all the feature to display label, error and value at the same time):\r\n- `inputValue`\r\n\r\nIf your are using a normal `EditText` and other views to show label, error text and error icon you have to specify the\r\nfollowing ids:\r\n- `inputLabel`\r\n- `inputEditText`\r\n- `inputErrorText`\r\n- `inputErrorImage`\r\n\r\n##### CheckBox Field\r\n- `checkboxLabel`\r\n- `checkboxView`\r\n- `checkboxTextView`\r\n- `checkboxErrorImage`\r\n\r\n##### Toggle Field\r\n- `toggleLabel`\r\n- `toggleView`\r\n- `toggleTextView`\r\n- `toggleErrorImage`\r\n\r\n##### Exception\r\n- `exceptionLabel`\r\n- `exceptionTextView`\r\n- `exceptionImage`\r\n\r\n##### Loading\r\n- `loadingLabel`\r\n- `loadingProgressBar`\r\n\r\n##### Section Header\r\n- `sectionTitle`",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}